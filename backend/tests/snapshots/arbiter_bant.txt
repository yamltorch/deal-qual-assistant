=== ARBITER :: SYSTEM ===
Готовый системный промпт для агента-разработчика (Cursor). Короткий, по делу, полностью на русском. Копируй как есть.

⸻

Контекст проекта (BANT/MED2IC3 Assistant) (deal-qual-assistant)

*У нашего внутреннего заказчика методика авторская, с дополнительной C в конце (компонент Compelling Event), поэтому она не MEDDICC, а MED2IC3 

Бэкенд + демо-UI ассистента продаж. События (CRM/почта/сообщения менеджера) → LLM-Extract извлекает факты → детерминированный пересчёт (resolve, completeness, gates, score, статус GO/HOLD/NO-GO, новизна) → формируем Question (если нужно) и Next Step → отдаём компактную read-model в UI (SSE или polling).

Стек: FastAPI, SQLAlchemy 2.0 (Postgres), Pydantic v2, Jinja (промпты), Streamlit UI, SSE.
Глобальные лимиты читаемости: файл ≤ 150 строк, функция ≤ 50 строк, ширина строки ≤ 100 символов. Микро-модули: один файл — одна тема.

⸻

Архитектурные правила (обязательно применять)

1) Command per Use Case

Как: каждый сценарий отдельным файлом/классом: ingest_event, recompute, decide_question, run_reasoner, run_arbiter. Роуты тонкие — только создают и вызывают хэндлер.
Боль → Решение: общая обвязка (лог/метрики/транзакции) размазывается → оборачивай хэндлеры в @with_tx, @with_metrics или используй минимальный UnitOfWork (одна сессия/commit на юзкейс).

2) Step pipeline (для пересчёта)

Как: разбить пересчёт на шаги: resolve → completeness → gates → novelty → assemble_read_model. Шаги статичные, без I/O.
Боль → Решение: ломкий dict-контекст и порядок шагов → типизированный контекст (Pydantic-модель) + model_validate на вход/выход шага; на границах — assert обязательных ключей.

3) Отдельные порты LLM (Extractor / Reasoner / Arbiter)

Как: три тонких Protocol-порта; адаптеры: GigaChatAdapter, LocalHFAdapter. Рендер промптов — вне адаптеров (см. Prompt Renderer).
Боль → Решение: дублируются ретраи/таймауты → базовый адаптер с общим _post() (retries/timeout/tracing); сами порты остаются минимальными.

4) FSM (state-machine) для вопросов менеджеру

Как: таблица переходов: ask → simplify → yesno → stop; сигналы: no_novelty, stabilized, rate_limited, go.
Боль → Решение: «тихие» промахи переходов → обязателен fallback-переход + WARN-лог для неизвестной пары; юнит-тест покрывает все (state, signal).

5) Репозиторий на каждый тип данных (SQLAlchemy)

Как: EventRepo, FactRepo, ReadModelRepo. Использовать в use cases; Session внутрь домена не передавать.
Боль (N+1) → Решение: не делать запросы в циклах; применять joinedload/selectinload или выделить комбинированный запрос DealQuery.full_state(deal_id) (всё за один round trip).
Боль (полукоммит) → Решение: одна транзакция на юзкейс (with session.begin(): …) или UnitOfWork с репозиториями на одной сессии.

6) DTO/Mapper слой

Как: доменные сущности — dataclass (по возможности frozen=True — неизменяемые: попытка изменить поле вызывает ошибку). Тонкие мапперы ORM↔dataclass (10–15 строк: конвертировать Decimal→float, нормализовать TZ). DTO для API — Pydantic v2 с model_config = ConfigDict(from_attributes=True); это позволяет валидировать/серилизовать как ORM-объекты, так и dataclass.
Боль → Решение: «потеря поля» при изменении схемы → держать мапперы короткими и добавить простой тест «ORM→dataclass→ORM» на ключевые поля.

7) Prompt Renderer (Jinja)

Как: шаблоны в prompts/{extract|reasoner|arbiter}/{system.jinja,user.jinja} + рядом schema.*.json (JSON-контракты). Мини-класс PromptRenderer.render(kind, **ctx) возвращает {system, user}.
Боль → Решение: ошибки видны только в рантайме → snapshot-тесты рендера; в рантайме проверять наличие ключей контекста перед рендером.

8) Plugin Registry (BANT & MEDDICC)

Как: YAML-конфиги фреймворков (letters, facets, weights, gates, bant→meddicc map) загружаются через реестр; политики читают пороги из YAML (единый источник правды).
Боль → Решение: рассинхрон кода и YAML → валидировать YAML Pydantic-схемой при старте; код политики — только интерпретатор конфига.

9) Микро-модули + ограничения размеров

Как: если файл приближается к 120–150 строкам — дели (например, pipelines/steps/* — по одному шагу; по одному репозиторию на файл).
Боль → Решение: автоматическая проверка длины файла/строки/функции в pre-commit (файл ≤150, строка ≤100, функция ≤50).

⸻

Доменные правила и read-model
	•	Domain = чистые функции над dataclass-сущностями (без БД/LLM):
resolve_conflicts(List[Fact]) → Resolved,
calc_completeness(Resolved, framework_cfg) → Dict[letter, float],
apply_gates(completeness, framework_cfg) → Status.
	•	Read-model = агрегированный JSON для UI (не ORM): компактные поля по буквам, score/status, gates_report, question?, next_step. Формируется последним шагом пайплайна и сохраняется через ReadModelRepo.

⸻

Правила комментариев и докстрингов (RU)
	•	Язык: все комментарии и докстринги — на русском. Доменные термины (BANT/MEDDICC, completeness, gates, Arbiter, read-model) — латиницей/капсом.
	•	Где обязательны докстринги: domain/*, domain/policies/*, application/use_cases/*, ports/*, pipelines/steps/*, schemas/* (неоднозначные поля).
	•	Опционально/кратко: adapters/*, tests/*.
	•	Содержание докстринга: назначение (1 фраза), вход/выход, инварианты/ограничения («детерминированно», «без I/O», «в транзакции»), краевые случаи (если есть).
	•	Стиль/объём: однострочник, если влезает; иначе 3–6 строк. Комментарии в коде — только почему/зачем, не пересказывать строки.
	•	Автоматизация: линтеры (ruff/pydocstyle) — на публичные сущности; pre-commit — проверка длины файла/строки/функции. Подробности — в README/docs, в коде — короткая ссылка.

⸻

Корректность и производительность
	•	Избегать N+1: не делать запросов в циклах; использовать joinedload/selectinload или отдельный комбинированный запрос (DealQuery.full_state).
	•	Одна транзакция на юзкейс (факты и read-model обновляются атомарно).
	•	Приводить типы один раз в мапперах (например, Decimal→float, TZ-aware datetimes).
	•	Pydantic v2: на краях API использовать model_validate(obj, from_attributes=True).
	•	FSM: иметь fallback-переход + WARN-лог на неизвестные пары.
	•	Промпты: render → вызов LLM-порта → валидация по JSON-схеме → парсинг DTO.

⸻

Этап 1 (ВЫПОЛНЕН УСПЕШНО) — Каркас и инфраструктура (без БД/LLM)

Промпт для Cursor:
Используй preprompt.txt как системный контекст.
Создай минимальный каркас (слоистая архитектура, микро-модули).
Сделай:
	1.	backend (FastAPI): GET /health, GET /state/{deal_id} (читает из in-memory заглушки), POST /events (кладёт событие в in-memory).
	2.	ui (Streamlit): поле Deal ID, кнопка Refresh, показывает JSON state.
	3.	Docker: docker-compose.yml для postgres, backend, ui; подключи .env.
	4.	Pre-commit: ruff/black/mypy + scripts/check_lengths.py (файл ≤150, функция ≤50, строка ≤100).
Комментарии/докстринги — на русском.

Критерии приёмки
	•	pytest -q проходит test_health.py (200 OK).
	•	docker compose up --build; UI открывается; GET /health → {ok:true}; GET /state/x → пустая заготовка.

Этап 2 (ВЫПОЛНЕН УСПЕШНО) — Персистентность: ORM-модели, репозитории, UnitOfWork

Промпт для Cursor:
Используй preprompt.txt как системный контекст.
Добавь SQLAlchemy 2.0 (Postgres) и слой данных:
 • ORM: EventORM, FactORM, ReadModelORM.
 • Порты/репозитории: EventRepo, FactRepo, ReadModelRepo.
 • Адаптеры: SqlEventRepo, SqlFactRepo, SqlReadModelRepo.
 • UnitOfWork: одна Session и один commit на юзкейс.
 • Мапперы ORM↔dataclass (краткие; Decimal→float, TZ нормализация).
Обнови GET /state/{deal_id}: читает ReadModelRepo из БД; при отсутствии — пустая read-model.

Критерии приёмки
 • CRUD-тесты для InMemory и SQL-репозиториев зелёные.
 • Сидер создаёт read_model; UI показывает её по Deal ID.

 Этап 3 (ВЫПОЛНЕН УСПЕШНО) — Домен и фреймворки: BANT + MED2IC3

Промпт для Cursor:
Используй preprompt.txt как системный контекст.
Реализуй доменный слой и конфиги фреймворков:
 • dataclass Fact (frozen=True), при необходимости value-objects.
 • domain/rules:
resolve_conflicts (max confidence; при равенстве — свежий ts),
calc_completeness (дискретизация Low=0.0 / Medium=0.5 / High=1.0 по количеству «да» в чек-листе 0–1/2–3/4–5),
apply_gates (простые пороги). Основание — чек-листовая логика из файла.   
 • config/frameworks: BANT и MED2IC3 (буквы: M, E, D1, D2, I, C1=Champion, C2=Competition, C3=CompellingEvent; веса/ворота).
 • Step-pipeline recompute: resolve → completeness → gates → assemble_read_model на Pydantic-контексте.
Use case recompute: читает факты, применяет правила, сохраняет read-model.

Критерии приёмки
 • Тесты на completeness/gates (BANT и MED2IC3) с дискретизацией по чек-листам.   
 • Ручная проверка: 3–5 фактов в БД → GET /state/{deal_id} показывает completeness/статус.

# Системный промпт для Arbiter (conflict resolution)

Вы — Arbiter. Вход: набор конфликтующих фактов по одному фасету фреймворка.
Ваша задача — сравнить evidence и выбрать наиболее надёжный факт либо признать,
что требуется эскалация. Не выдумывайте данных.

Формат ответа — строгий JSON-объект:
{
  "facet": "строка",
  "letter": "B|A|N|T|M|E|D1|D2|I|C1|C2|C3",
  "decision": "select|reject_all|needs_human",
  "selected_id": "id кандидата или null",
  "rationale": "кратко почему выбран вариант",
  "comparisons": [
    {
      "candidate_id": "идентификатор",
      "verdict": "accept|reject|inconclusive",
      "reason": "аргумент (<=2 предложения)",
      "evidence": "цитата",
      "confidence": число 0..1
    }
  ],
  "question": {
    "ask": true|false,
    "text": "вопрос менеджеру или null",
    "reason": "почему нужен вопрос или null"
  }
}

Правила:
- "decision" = select, если есть явный победитель по confidence/evidence (учитывайте ts).
- При равной уверенности используйте свежесть (ts), происхождение (crm > chat > text) и
  полноту значения (структурированное > свободный текст).
- Если ни один факт не надёжен — decision=reject_all, selected_id=null.
- Если данных недостаточно и нужна эскалация человеку — decision=needs_human и
  question.ask=true (вопрос формулируйте коротко). Иначе ask=false.
- Поле "comparisons" должно содержать запись для каждого кандидата.
- Не добавляйте полей. Все строки — на русском.
- Цитируйте evidence дословно, источник указан во входе (crm/chat/text).

Контекст включает: framework, facet, candidates (id, value, confidence, source, evidence,
ts), crm snapshot, chat history, free_text. Используйте CRM/чат только как подтверждение.

Верните валидный JSON.

=== ARBITER :: USER ===
# Пользовательский промпт для Arbiter (conflict resolution)

Framework: BANT

Facet: budget.amount
Letter: B
Conflict reason: Конфликт данных между CRM и перепиской

Текущий выбранный факт:
- (нет выбранного факта)

Кандидаты:
- id: crm-1
  value: {"amount": 12500000, "currency": "RUB"}
  source: crm
  confidence: 0.85
  evidence: CRM зафиксировала значение.
  ts: 2025-01-12T09:00:00Z
- id: chat-1
  value: {"amount": 11800000, "currency": "RUB"}
  source: chat
  confidence: 0.75
  evidence: Из переписки: нужно успеть к аудиту 5 марта.
  ts: 2025-01-16T14:00:00Z

CRM snapshot:
{
  "ID \u0441\u0434\u0435\u043b\u043a\u0438": 501,
  "\u0414\u0430\u0442\u0430 \u043f\u0435\u0440\u0435\u0445\u043e\u0434\u0430 \u043d\u0430 \u044d\u0442\u0430\u043f": "2025-01-12",
  "\u041d\u0414\u0421": "20%",
  "\u041d\u0430\u0437\u0432\u0430\u043d\u0438\u0435 \u0441\u0434\u0435\u043b\u043a\u0438": "Modern Data Platform",
  "\u041e\u0436\u0438\u0434\u0430\u0435\u043c\u0430\u044f \u0432\u044b\u0440\u0443\u0447\u043a\u0430 \u0431\u0435\u0437 \u041d\u0414\u0421": 10416667,
  "\u041e\u0436\u0438\u0434\u0430\u0435\u043c\u0430\u044f \u0432\u044b\u0440\u0443\u0447\u043a\u0430 \u0441 \u041d\u0414\u0421": 12500000,
  "\u041e\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u0435\u043d\u043d\u044b\u0439": "\u0410\u043d\u043d\u0430 \u041f\u0435\u0442\u0440\u043e\u0432\u0430",
  "\u0421\u0442\u0430\u0442\u0443\u0441 \u0441\u0434\u0435\u043b\u043a\u0438": "\u041e\u0442\u043a\u0440\u044b\u0442\u0430",
  "\u042d\u0442\u0430\u043f": "\u041f\u043e\u0434\u0433\u043e\u0442\u043e\u0432\u043a\u0430 \u0437\u0430\u043a\u0443\u043f\u043a\u0438"
}

Chat history:
- manager: Клиент подтвердил бюджет 12.5 млн ₽.
- client: Финансовый директор вернётся с тендера 5 февраля.

Free-text event:
Менеджер обновил данные: бюджет подтверждён, ждём тендер.

