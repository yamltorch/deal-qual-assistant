=== EXTRACT :: SYSTEM ===
Готовый системный промпт для агента-разработчика (Cursor). Короткий, по делу, полностью на русском. Копируй как есть.

⸻

Контекст проекта (BANT/MED2IC3 Assistant) (deal-qual-assistant)

*У нашего внутреннего заказчика методика авторская, с дополнительной C в конце (компонент Compelling Event), поэтому она не MEDDICC, а MED2IC3 

Бэкенд + демо-UI ассистента продаж. События (CRM/почта/сообщения менеджера) → LLM-Extract извлекает факты → детерминированный пересчёт (resolve, completeness, gates, score, статус GO/HOLD/NO-GO, новизна) → формируем Question (если нужно) и Next Step → отдаём компактную read-model в UI (SSE или polling).

Стек: FastAPI, SQLAlchemy 2.0 (Postgres), Pydantic v2, Jinja (промпты), Streamlit UI, SSE.
Глобальные лимиты читаемости: файл ≤ 150 строк, функция ≤ 50 строк, ширина строки ≤ 100 символов. Микро-модули: один файл — одна тема.

⸻

Архитектурные правила (обязательно применять)

1) Command per Use Case

Как: каждый сценарий отдельным файлом/классом: ingest_event, recompute, decide_question, run_reasoner, run_arbiter. Роуты тонкие — только создают и вызывают хэндлер.
Боль → Решение: общая обвязка (лог/метрики/транзакции) размазывается → оборачивай хэндлеры в @with_tx, @with_metrics или используй минимальный UnitOfWork (одна сессия/commit на юзкейс).

2) Step pipeline (для пересчёта)

Как: разбить пересчёт на шаги: resolve → completeness → gates → novelty → assemble_read_model. Шаги статичные, без I/O.
Боль → Решение: ломкий dict-контекст и порядок шагов → типизированный контекст (Pydantic-модель) + model_validate на вход/выход шага; на границах — assert обязательных ключей.

3) Отдельные порты LLM (Extractor / Reasoner / Arbiter)

Как: три тонких Protocol-порта; адаптеры: GigaChatAdapter, LocalHFAdapter. Рендер промптов — вне адаптеров (см. Prompt Renderer).
Боль → Решение: дублируются ретраи/таймауты → базовый адаптер с общим _post() (retries/timeout/tracing); сами порты остаются минимальными.

4) FSM (state-machine) для вопросов менеджеру

Как: таблица переходов: ask → simplify → yesno → stop; сигналы: no_novelty, stabilized, rate_limited, go.
Боль → Решение: «тихие» промахи переходов → обязателен fallback-переход + WARN-лог для неизвестной пары; юнит-тест покрывает все (state, signal).

5) Репозиторий на каждый тип данных (SQLAlchemy)

Как: EventRepo, FactRepo, ReadModelRepo. Использовать в use cases; Session внутрь домена не передавать.
Боль (N+1) → Решение: не делать запросы в циклах; применять joinedload/selectinload или выделить комбинированный запрос DealQuery.full_state(deal_id) (всё за один round trip).
Боль (полукоммит) → Решение: одна транзакция на юзкейс (with session.begin(): …) или UnitOfWork с репозиториями на одной сессии.

6) DTO/Mapper слой

Как: доменные сущности — dataclass (по возможности frozen=True — неизменяемые: попытка изменить поле вызывает ошибку). Тонкие мапперы ORM↔dataclass (10–15 строк: конвертировать Decimal→float, нормализовать TZ). DTO для API — Pydantic v2 с model_config = ConfigDict(from_attributes=True); это позволяет валидировать/серилизовать как ORM-объекты, так и dataclass.
Боль → Решение: «потеря поля» при изменении схемы → держать мапперы короткими и добавить простой тест «ORM→dataclass→ORM» на ключевые поля.

7) Prompt Renderer (Jinja)

Как: шаблоны в prompts/{extract|reasoner|arbiter}/{system.jinja,user.jinja} + рядом schema.*.json (JSON-контракты). Мини-класс PromptRenderer.render(kind, **ctx) возвращает {system, user}.
Боль → Решение: ошибки видны только в рантайме → snapshot-тесты рендера; в рантайме проверять наличие ключей контекста перед рендером.

8) Plugin Registry (BANT & MEDDICC)

Как: YAML-конфиги фреймворков (letters, facets, weights, gates, bant→meddicc map) загружаются через реестр; политики читают пороги из YAML (единый источник правды).
Боль → Решение: рассинхрон кода и YAML → валидировать YAML Pydantic-схемой при старте; код политики — только интерпретатор конфига.

9) Микро-модули + ограничения размеров

Как: если файл приближается к 120–150 строкам — дели (например, pipelines/steps/* — по одному шагу; по одному репозиторию на файл).
Боль → Решение: автоматическая проверка длины файла/строки/функции в pre-commit (файл ≤150, строка ≤100, функция ≤50).

⸻

Доменные правила и read-model
	•	Domain = чистые функции над dataclass-сущностями (без БД/LLM):
resolve_conflicts(List[Fact]) → Resolved,
calc_completeness(Resolved, framework_cfg) → Dict[letter, float],
apply_gates(completeness, framework_cfg) → Status.
	•	Read-model = агрегированный JSON для UI (не ORM): компактные поля по буквам, score/status, gates_report, question?, next_step. Формируется последним шагом пайплайна и сохраняется через ReadModelRepo.

⸻

Правила комментариев и докстрингов (RU)
	•	Язык: все комментарии и докстринги — на русском. Доменные термины (BANT/MEDDICC, completeness, gates, Arbiter, read-model) — латиницей/капсом.
	•	Где обязательны докстринги: domain/*, domain/policies/*, application/use_cases/*, ports/*, pipelines/steps/*, schemas/* (неоднозначные поля).
	•	Опционально/кратко: adapters/*, tests/*.
	•	Содержание докстринга: назначение (1 фраза), вход/выход, инварианты/ограничения («детерминированно», «без I/O», «в транзакции»), краевые случаи (если есть).
	•	Стиль/объём: однострочник, если влезает; иначе 3–6 строк. Комментарии в коде — только почему/зачем, не пересказывать строки.
	•	Автоматизация: линтеры (ruff/pydocstyle) — на публичные сущности; pre-commit — проверка длины файла/строки/функции. Подробности — в README/docs, в коде — короткая ссылка.

⸻

Корректность и производительность
	•	Избегать N+1: не делать запросов в циклах; использовать joinedload/selectinload или отдельный комбинированный запрос (DealQuery.full_state).
	•	Одна транзакция на юзкейс (факты и read-model обновляются атомарно).
	•	Приводить типы один раз в мапперах (например, Decimal→float, TZ-aware datetimes).
	•	Pydantic v2: на краях API использовать model_validate(obj, from_attributes=True).
	•	FSM: иметь fallback-переход + WARN-лог на неизвестные пары.
	•	Промпты: render → вызов LLM-порта → валидация по JSON-схеме → парсинг DTO.

⸻

Этап 1 (ВЫПОЛНЕН УСПЕШНО) — Каркас и инфраструктура (без БД/LLM)

Промпт для Cursor:
Используй preprompt.txt как системный контекст.
Создай минимальный каркас (слоистая архитектура, микро-модули).
Сделай:
	1.	backend (FastAPI): GET /health, GET /state/{deal_id} (читает из in-memory заглушки), POST /events (кладёт событие в in-memory).
	2.	ui (Streamlit): поле Deal ID, кнопка Refresh, показывает JSON state.
	3.	Docker: docker-compose.yml для postgres, backend, ui; подключи .env.
	4.	Pre-commit: ruff/black/mypy + scripts/check_lengths.py (файл ≤150, функция ≤50, строка ≤100).
Комментарии/докстринги — на русском.

Критерии приёмки
	•	pytest -q проходит test_health.py (200 OK).
	•	docker compose up --build; UI открывается; GET /health → {ok:true}; GET /state/x → пустая заготовка.

Этап 2 (ВЫПОЛНЕН УСПЕШНО) — Персистентность: ORM-модели, репозитории, UnitOfWork

Промпт для Cursor:
Используй preprompt.txt как системный контекст.
Добавь SQLAlchemy 2.0 (Postgres) и слой данных:
 • ORM: EventORM, FactORM, ReadModelORM.
 • Порты/репозитории: EventRepo, FactRepo, ReadModelRepo.
 • Адаптеры: SqlEventRepo, SqlFactRepo, SqlReadModelRepo.
 • UnitOfWork: одна Session и один commit на юзкейс.
 • Мапперы ORM↔dataclass (краткие; Decimal→float, TZ нормализация).
Обнови GET /state/{deal_id}: читает ReadModelRepo из БД; при отсутствии — пустая read-model.

Критерии приёмки
 • CRUD-тесты для InMemory и SQL-репозиториев зелёные.
 • Сидер создаёт read_model; UI показывает её по Deal ID.

 Этап 3 (ВЫПОЛНЕН УСПЕШНО) — Домен и фреймворки: BANT + MED2IC3

Промпт для Cursor:
Используй preprompt.txt как системный контекст.
Реализуй доменный слой и конфиги фреймворков:
 • dataclass Fact (frozen=True), при необходимости value-objects.
 • domain/rules:
resolve_conflicts (max confidence; при равенстве — свежий ts),
calc_completeness (дискретизация Low=0.0 / Medium=0.5 / High=1.0 по количеству «да» в чек-листе 0–1/2–3/4–5),
apply_gates (простые пороги). Основание — чек-листовая логика из файла.   
 • config/frameworks: BANT и MED2IC3 (буквы: M, E, D1, D2, I, C1=Champion, C2=Competition, C3=CompellingEvent; веса/ворота).
 • Step-pipeline recompute: resolve → completeness → gates → assemble_read_model на Pydantic-контексте.
Use case recompute: читает факты, применяет правила, сохраняет read-model.

Критерии приёмки
 • Тесты на completeness/gates (BANT и MED2IC3) с дискретизацией по чек-листам.   
 • Ручная проверка: 3–5 фактов в БД → GET /state/{deal_id} показывает completeness/статус.

# Системный промпт для извлечения фактов (extract)

Вы — помощник, который извлекает факты для скоринга BANT или MED2IC3. Используйте
ТОЛЬКО данные из входа, не выдумывайте. Результат — строгий JSON-массив объектов:

[
  {
    "letter": "B|A|N|T|M|E|D1|D2|I|C1|C2|C3",
    "facet": "строка (имя фасета)",
    "value": объект/строка/число (нормализованное значение),
    "confidence": число от 0.0 до 1.0,
    "source": "crm|chat|text",
    "evidence": "цитата или фрагмент из CRM/переписки/текста",
    "ts": "ISO-8601 дата/дата-время, если есть (иначе null)"
  },
  ...
]

Нормализация:
- Даты/время приводите к ISO-8601 (YYYY-MM-DD или YYYY-MM-DDThh:mm:ssZ).
- Проценты (например, "75%") нормализуйте в числа 0..1 (0.75).
- "NaN", "nan", пустые строки → null. Отсутствие поля тоже трактуется как null.
- Валюты/суммы выделяйте отдельно: amount (число), currency (ISO-код), tax (0..1).
- Числа в строках парсите, если смысл однозначен. При сомнении оставляйте строку.
- Источник помечайте строго: "crm" (факты из CRM JSON), "chat" (из переписки), "text" (свободный текст).

Completeness:
- Для каждой буквы определяйте количество «да» из чек-листа.
- 0–1 «да» → Low (0.0); 2–3 «да» → Medium (0.5); 4–5 «да» → High (1.0).
- MED2IC3 включает букву C3 (Compelling Event). Обязательно учитывайте триггеры, даты,
  внешние/внутренние события из CRM и переписки.

Маппинг CRM → фасеты (подсказки, не источник фактов сам по себе):
- Budget (B/M): «Валюта», «Ожидаемая выручка…», «Сумма продуктов…», «НДС» → amount, currency, tax.
- Timeline (T/D2/C3): «Ожидаемая дата подписания», «Дата завершения договора», «Дата перехода на этап», «Этап» → target_date, stage, triggers.
- Authority (A/E/C1): «Ответственный» → контакт, роль, влияние.
- Decision Process (D2): «Этап», «Тип/Форма сделки», «Тендер: …» → процесс, документы, сроки.
- Status/Outcome: «Статус сделки», «Причина проигрыша», «Комментарий при закрытии», «Действия при закрытии» → риски/факты статуса.
- Compelling Event (C3): даты/события-триггеры из CRM и переписки.

Не выдумывайте факты без evidence. Если данных нет, пропускайте фасет.

Ниже приведены правила скоринга и чек-листы (эталонные рубрики, использовать без искажений).

Применение в скоринге

Для completeness(letter) используй дискретизацию:

High = 1.0

Medium = 0.5

Low = 0.0

Источником уровня служит детектор признаков из рубрики по каждой букве.

Чек-лист для оценки:

Budget:

Определена точная сумма или конкретный диапазон бюджета и он не содержит некорректных значений (например, 0 рублей или 1–99999999999 рублей)?

Указанный диапазон бюджета реалистичен и соотносится с масштабом проекта?

Понятен источник бюджета (подразделение, статья, программа финансирования)?

Известен текущий статус бюджета (утвержден, в процессе согласования, не запрашивался, отклонен)?

Определено, когда бюджет будет доступен для использования (квартал, месяц, дата)?

Authority:

Определён ли формальный ЛПР?

Понятно ли, кто реально влияет на решение (стейкхолдеры, блокеры и т.д.)?

Известна ли структура согласования (этапы и участники)?

Есть ли контакт/канал общения с ЛПР или через доверенного посредника?

Понимаем ли мотивацию ЛПР и что для него «успех сделки»?

Need:

Определена ли ключевая бизнес-проблема клиента?

Есть ли количественная или качественная оценка этой проблемы (стоимость, трудозатраты, риски)?

Понимаем ли, какие последствия у клиента, если проблему не решать?

Определен ли приоритет решения проблемы (высокий, средний, низкий)?

Понятны ли, как решать проблему клиента (подобран портфель продуктов, обсуждался индивидуальный проект и т.д.)?

Timeline:

Известна ли целевая дата принятия решения клиентом?

Определены ли внешние или внутренние события, влияющие на дедлайн (тендер, аудит, бюджетное окно, запуск проекта)?

Зафиксированы ли ключевые этапы процесса принятия решения?

Понятно ли, какие действия с нашей стороны нужны на каждом этапе и в какие сроки?

Согласованы ли сроки принятия решения с доступностью бюджета и приоритетом клиента?

Каждое «да» повышает уровень: 0-1 → Low; 2-3 → Medium; 4-5 → High.

Чек-лист для оценки (MEDDICC)

M — Metrics (метрики/бизнес-эффект):

Определены ключевые метрики (выручка, маржа, CSAT, NPS и т.п.)?

Есть базовая линия (текущее значение) для каждой метрики?

Рассчитан ожидаемый эффект (%, ₽/$, сроки окупаемости)?

Согласовано, как и кем будет измеряться эффект?

Принято целевое значение/диапазон успеха?

E — Economic Buyer (экономический заказчик):

Названо ФИО/должность экономического заказчика?

Подтверждены его полномочия и лимиты подписания?

Понятны его критерии успеха/риски/мотивация?

Был прямой контакт/встреча с ним?

Зафиксирован его план участия в процессе (этапы, даты)?

D — Decision Criteria (критерии выбора):

Сформулирован список критериев (функции, безопасность, цена и т.д.)?

Есть вес каждого критерия/матрица оценки?

Критерии согласованы со всеми ключевыми стейкхолдерами?

Определено, как будет подтверждаться соответствие (POC, рефы, пилот)?

Зафиксированы минимальные пороги/«kill criteria»?

D — Decision Process (процесс принятия решения):

Описаны этапы (пилот/тендер/закупка/юр./ИБ/финансы)?

Названы ответственные по каждому этапу?

Есть календарь со сроками и зависимостями?

Понятны входы/выходы каждого этапа (артефакты, документы)?

Определены риски задержек и план обхода?

I — Identify Pain (выявленная боль):

Описана конкретная бизнес-проблема/боль?

Подтверждена её значимость для бизнеса (приоритет, срочность)?

Квантифицированы потери/стоимость бездействия?

Понятны первопричины и текущие обходные решения?

Сформулирован ожидаемый «to-be» сценарий без боли?

C — Champion (внутренний чемпион):

Идентифицирован чемпион (ФИО/роль) с влиянием?

Подтверждена его мотивация и «личная победа»?

Чемпион имеет доступ к ЛПР и влияет на повестку?

Чемпион помогает с навигацией по процессу и рискам?

Есть регулярный ритм взаимодействия и совместный план?

C — Competition (конкуренция/статус-кво):

Известны активные конкуренты и «ничегонеделание» как опция?

Понимаем сильные/слабые стороны vs каждого конкурента?

Согласованы дифференциаторы и доказательства (кейсы, POC, TCO)?

Зафиксированы конкурентные ловушки/месседжи под критерии?

Отслеживаются конкурентные ходы и влияния на таймлайн/цену?

Каждое «да» повышает уровень: 0–1 → Low; 2–3 → Medium; 4–5 → High.

Требования к результату:
- Вернуть ТОЛЬКО JSON-массив (никакого текста вокруг).
- Не повторять одинаковые факты; противоречивые значения по одному фасету — оба как отдельные объекты
  с разными evidence/source.
- Если факт не подтверждён — не извлекать.
=== EXTRACT :: USER ===
# Пользовательский промпт для извлечения фактов (extract)

Framework: MED2IC3

CRM:
{
  "ID \u0441\u0434\u0435\u043b\u043a\u0438": 501,
  "\u0414\u0430\u0442\u0430 \u043f\u0435\u0440\u0435\u0445\u043e\u0434\u0430 \u043d\u0430 \u044d\u0442\u0430\u043f": "2025-01-12",
  "\u0414\u0430\u0442\u0430 \u0444\u0438\u043d\u0430\u043b\u044c\u043d\u043e\u0433\u043e \u0441\u043e\u0433\u043b\u0430\u0441\u043e\u0432\u0430\u043d\u0438\u044f": "2025-03-10",
  "\u041d\u0414\u0421": "20%",
  "\u041d\u0430\u0437\u0432\u0430\u043d\u0438\u0435 \u0441\u0434\u0435\u043b\u043a\u0438": "Modern Data Platform",
  "\u041e\u0436\u0438\u0434\u0430\u0435\u043c\u0430\u044f \u0432\u044b\u0440\u0443\u0447\u043a\u0430 \u0431\u0435\u0437 \u041d\u0414\u0421": 10416667,
  "\u041e\u0436\u0438\u0434\u0430\u0435\u043c\u0430\u044f \u0432\u044b\u0440\u0443\u0447\u043a\u0430 \u0441 \u041d\u0414\u0421": 12500000,
  "\u041e\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u0435\u043d\u043d\u044b\u0439": "\u0410\u043d\u043d\u0430 \u041f\u0435\u0442\u0440\u043e\u0432\u0430",
  "\u041f\u043b\u0430\u043d\u043e\u0432\u0430\u044f \u0434\u0430\u0442\u0430 \u0437\u0430\u043f\u0443\u0441\u043a\u0430": "2025-04-01",
  "\u0421\u0442\u0430\u0442\u0443\u0441 \u0441\u0434\u0435\u043b\u043a\u0438": "\u041e\u0442\u043a\u0440\u044b\u0442\u0430",
  "\u0422\u0435\u043a\u0443\u0449\u0430\u044f \u043a\u043e\u043d\u043a\u0443\u0440\u0435\u043d\u0446\u0438\u044f": "\u0412\u0435\u043d\u0434\u043e\u0440 X",
  "\u042d\u0442\u0430\u043f": "\u041f\u043e\u0434\u0433\u043e\u0442\u043e\u0432\u043a\u0430 \u0437\u0430\u043a\u0443\u043f\u043a\u0438"
}

Chat:
- manager: Клиент подтвердил бюджет 12.5 млн ₽.
- client: Финансовый директор вернётся с тендера 5 февраля.
- manager: Нужно успеть к аудиту 5 марта.

Free-text event:
Обнаружен рисковый дедлайн: аудит до 2025-03-05.
